# Lab 06

## Mancala Controller and Tests

As an initial class diagram, we took this version:

![](../../portfolios/jessica/assets/lab03/mancala_class.png)

During the discussion to the improvements of our Mancala class diagram, Ihar suggested that we have one Pit class, and have PlayingPit and Kalah inherit from it. SInce they both share the same attribute. Tahira and I were on the side of having it as it is because they are different things if we think about functionality that will happen on those classes. I also felt that it was uneccessary to create a new class just because they shared one property

Ihar gave a good point about the new class not being unecessary because we can have shared getters and setters on this class.  He also argued that since the diagram does not show the differences, then it was better to combine them into one class. We eventually voted, majority went for inheritance. The new improvement involved introducing a parent class for pits.      
&nbsp;

### Fulib modifications
Fulib **Scenario** was tuned specifically to produce the closest to desirable class diagram via https://www.fulib.org/editor:

```
# Mancala

There is a player with name Alice and with turn true.
There is a player with name Bob and with turn false.
There is a game with isOver false.
The game has players Alice and Bob.
The game has message no messages.
There are pits with 6 stones.
Alice has a kalah of type Kalah.
Bob has a kalah of type Kalah.
Every kalah is a Pit.
Alice has playing-pits of type PlayingPit.
Bob has playing-pits of type PlayingPit.
Every playing-pit is a Pit.
```      

**Class diagram** generated by https://www.fulib.org/editor:      
![](../../portfolios/ihar/lab-notes/lab06/mancala.svg)

Java **test code** generated by https://www.fulib.org/editor (would be almost all discarded in the steps below, as it's possible to simplify it significantly using constructors):
```Java
Player alice = new Player();
alice.setName("Alice");
alice.setTurn(true);
Player bob = new Player();
bob.setName("Bob");
bob.setTurn(false);
Game game = new Game();
game.setIsOver(false);
game.withPlayers(alice, bob);
game.setMessage("no messages");
Pit pits = new Pit();
pits.setStones(6);
FulibTools.objectDiagrams().dumpSVG("/tmp/fulib.org/api/runcodegen/0c8a8c41-6011-49c9-aba2-681a41a50d96/src/org/example/mancala.svg", alice, bob, game, pits);
```      
&nbsp;

### Web API development
Here's the Mancala [source code](../../portfolios/ihar/lab-notes/lab06/mancala-controller) with HTTP API using [Spark](https://sparkjava.com). There are 3 endpoints:

Endpoint | Description
---------|------------
`GET /game_state` | Returns the status of the game
`GET /add_player?name=<name>` | Adds a player to the game
`GET /make_turn?pitIndex=<index>` | Makes a turn in the game according to the rules given pit location

Example gameplay:
```shell
$ curl "http://localhost:8000/add_player?name=Alice"
$ curl "http://localhost:8000/add_player?name=Bob"
$ curl "http://localhost:8000/game_state"
$ curl "http://localhost:8000/make_turn?pitIndex=1"
$ curl "http://localhost:8000/make_turn?pitIndex=7"
$ curl "http://localhost:8000/game_state"
```

Mancala objects diagram generated from the code by Fulib:
![](../../portfolios/ihar/lab-notes/lab06/mancala-controller/mancala_objects.svg)

### Test 1
```
    Game game = new Game();
    Pit pit = new Pit(10);
    Player alice = new Player("Alice", game);
    Player bob = new Player("Bob", game);
    game.addPlayer(alice);
    game.addPlayer(bob);
    pit.setPlayer(bob);
    pit.setPlayer(alice);
    PlayingPit playingPit = new PlayingPit(alice);
    playingPit.setPlayer(alice);

    FulibTools.objectDiagrams().dumpSVG("mancala_pepples.svg", alice, bob, game,pit,playingPit);
```
```
Scenario


```

### Test 2
```
# Alice gets another turn when landing with the last turn

There is the Pit fpit1 with id 1, with pebbles 2.
There is the Pit fpit2 with id 2, with pebbles 2.
There is the Pit fpit3 with id 3, with pebbles 0.
There is the Pit fpit4 with id 4, with pebbles 3.
There is the Pit fpit5 with id 5, with pebbles 3.
There is the Pit fpit6 with id 6, with pebbles 3.

There is the Pit lpit1 with id 7, with pebbles 2.
There is the Pit lpit2 with id 8, with pebbles 2.
There is the Pit lpit3 with id 9, with pebbles 2.
There is the Pit lpit4 with id 10, with pebbles 2.
There is the Pit lpit5 with id 11, with pebbles 2.
There is the Pit lpit6 with id 12, with pebbles 2.

There is the Kalah fhouse with pebbles 1.
There is the Kalah lhouse with pebbles 0.

There is the Player player1 with name Alice.
There is the Player player2 with name Bob.

fpit1 has owner and is one of the pits of the player1. 
fpit2 has owner and is one of the pits of the player1.
fpit3 has owner and is one of the pits of the player1. 
fpit4 has owner and is one of the pits of the player1.
fpit5 has owner and is one of the pits of the player1. 
fpit6 has owner and is one of the pits of the player1.
lpit1 has owner and is one of the pits of the player2. 
lpit2 has owner and is one of the pits of the player2.
lpit3 has owner and is one of the pits of the player2. 
lpit4 has owner and is one of the pits of the player2.
lpit5 has owner and is one of the pits of the player2. 
lpit6 has owner and is one of the pits of the player2.

fhouse has owner and is kalah of the player1.
lhouse has owner and is kalah of the player2.

There is the GameSystem mancala with players player1, player2.

mancala has turn player1.

We call pickfrom on player1 with pitId 3.
```
Test
```
Pit fpit1 = new Pit();
fpit1.setId(1);
fpit1.setPebbles(2);
Pit fpit2 = new Pit();
fpit2.setId(2);
fpit2.setPebbles(2);
Pit fpit3 = new Pit();
fpit3.setId(3);
fpit3.setPebbles(0);
Pit fpit4 = new Pit();
fpit4.setId(4);
fpit4.setPebbles(3);
Pit fpit5 = new Pit();
fpit5.setId(5);
fpit5.setPebbles(3);
Pit fpit6 = new Pit();
fpit6.setId(6);
fpit6.setPebbles(3);
Pit lpit1 = new Pit();
lpit1.setId(7);
lpit1.setPebbles(2);
Pit lpit2 = new Pit();
lpit2.setId(8);
lpit2.setPebbles(2);
Pit lpit3 = new Pit();
lpit3.setId(9);
lpit3.setPebbles(2);
Pit lpit4 = new Pit();
lpit4.setId(10);
lpit4.setPebbles(2);
Pit lpit5 = new Pit();
lpit5.setId(11);
lpit5.setPebbles(2);
Pit lpit6 = new Pit();
lpit6.setId(12);
lpit6.setPebbles(2);
Kalah fhouse = new Kalah();
fhouse.setPebbles(1);
Kalah lhouse = new Kalah();
lhouse.setPebbles(0);
Player player1 = new Player();
player1.setName("Alice");
Player player2 = new Player();
player2.setName("Bob");
fpit1.setOwner(player1);
fpit2.setOwner(player1);
fpit3.setOwner(player1);
fpit4.setOwner(player1);
fpit5.setOwner(player1);
fpit6.setOwner(player1);
lpit1.setOwner(player2);
lpit2.setOwner(player2);
lpit3.setOwner(player2);
lpit4.setOwner(player2);
lpit5.setOwner(player2);
lpit6.setOwner(player2);
fhouse.setOwner(player1);
lhouse.setOwner(player2);
GameSystem mancala = new GameSystem();
mancala.withPlayers(player1, player2);
mancala.setTurn(player1);
player1.pickFrom(3);
FulibTools.objectDiagrams().dumpSVG("/tmp/fulib.org/api/runcodegen/7af9ed89-ec98-4759-ac2f-7a3a8cdcdf62/src/org/example/aliceGetsAnotherTurnWhenLandingWithTheLastTurn.svg", fhouse, fpit1, fpit2, fpit3, fpit4, fpit5, fpit6, lhouse, lpit1, lpit2, lpit3, lpit4, lpit5, lpit6, mancala, player1, player2);

```

```
Scenario

Alice plays a game against Bob. Alice starts the game first.
Alice picks the pebbles in the 3rd pit and puts them to other pits one by one.
The last pebble goes into his Kalah.
Alice gets a chance to continue another turn.
So, Bob needs to wait for the next turn.

```

### Test 3

...    

&nbsp;

## Component Diagram Mancala Network Game

**High level view**:      
![](../../portfolios/ihar/lab-notes/lab06/mancala-mobile.png)

**Detailed view** of the server:      
![](../../portfolios/ihar/lab-notes/lab06/mancala-server.png)

**Discussion**:      
- These diagrams could be a good addition to existing Mancala requirements. Especially useful is the server diagram as it clearly states the requirements, `Game` and `WebConnector` interfaces.
- High-level diagram is less useful, because at the moment we see only that the mobile app communicates with the server via HTTP API. We can specify this requirement in one sentence without a need to draw a component diagram.      
&nbsp;

## Component Diagrams ATM Money Withdrawal

**High level overview of the atm machine software**      
![](../../portfolios/kenny/lab-notes/lab06/High_level_overview_of_the_atm_machine_software.PNG)

**Detailed overview of the software**      
![](../../portfolios/monika/lab-notes/lab06/ATM_software_component_diagram.PNG)

**Discussion**:      
- These diagrams could be a useful supplement to the standards for ATM Money withdrawals now in practice. The software operating on the ATM diagram is particularly valuable because it explicitly indicates the requirements, as well as the Database, Web Transaction, and ATM Network interfaces.

- The high-level diagram is especially helpful because it highlights the ATM's security, database, and transaction log.
